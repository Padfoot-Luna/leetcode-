`Middle `  `Random`

> 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。
>
> 不要使用系统的 Math.random() 方法。
>
> **进阶:**
>
> 1. `rand7()`调用次数的 [期望值](https://en.wikipedia.org/wiki/Expected_value) 是多少 ?
> 2. 你能否尽量少调用 `rand7()` ?

#### 1. 拒绝采样

```python
class Solution:
    def rand10(self):
        a, b = rand7(), rand7()
        if a<4 and b>4:
            return self.rand10()
        else:
            return (a+b)%10 + 1
```

$P=\frac{40}{49}$

$E[X]=P+2*P(1-P)+3*P(1-P)^2+...\approx $

```python
class Solution:
    def rand10(self):
        while 1:
            a = (rand7()-1) * 7 + rand7()
            if a <= 40:
                return  a%10 + 1
```

```python
class Solution:
    def rand10(self):
        while 1:
            a = (rand7()-1) * 7 + rand7()   # [1,49]
            if a <= 40:
                return  a%10 + 1
            a = (a%40-1)*7 + rand7()   # [1,63]
            if a <= 60:
                return a%10 + 1
            a = (a%60-1)*7 + rand7()   # [1,21]
            if a <= 20:            # 只拒绝一个采样
                return a%10 + 1  
```



---

### 总结

#### 1. 不均匀硬币，产生等概率

有一枚**不均匀**的硬币 `coin()`，能够返回 0、1 两个值，其概率分别为 0.6、0.4。要求使用这枚硬币，产生**均匀**的概率分布。

不难发现，连续抛两枚硬币得到 0 1 和 1 0 的概率分布是相同的。因此这道题的解法就是连续抛两次硬币，如果得到 0 1，返回 0；如果得到 1 0，返回 1；如果两次结果相同，则重新抛。



#### 2. 均匀硬币，产生不等概率

有一枚**均匀**的硬币 `coin()`，能够返回 0、1 两个值，其概率均为 0.5。要求编写一个函数 `coin_new()`，使得它返回指定的 0、1 概率分布。

1. 每抛一次硬币，会得到二进制数的一位

连续抛 $k$ 次硬币，可以等概率生成 $[0, 2^k-1]$ 的每个数，在 $[0, 2^k-1]$中，选取 $m$ 个数返回 0，$n$ 个数返回 1，则 0、1 的概率分别为$ \frac{m}{m+n}$ 、$\frac{n}{m+n}$.
$k$ 最多则没有限制，我们总可以通过抛更多次硬币来解决问题，只需要把无用的数字舍弃即可。​	



#### 3. RandM() 生成 RandN()

`Rand7()` 视作一个 **7 进制位的生成器**，每执行$k$次 `Rand7()`，将得到一个$k$位的 7 进制整数，在 $[0, 7^k-1]$ 范围内均匀分布。

1. 已知 RandM() 可以等概率的生成 [0, M-1] 范围的随机整数，那么执行 k 次，每次都得到 M 进制的一位，可以等概率生成 $[0, M^k-1]$  范围的随机整数，记为 $x$。 RandN 至少需要 N 个均匀随机整数，因此只需要取 $k$，使得 $ M^k-1 >= N$ 即可。
2. 此时有多种方式得到 RandN： 
    1. 一种是只在 $x \in [0, N-1]$ 时返回 $x$
    2. 另一种是利用取余运算，在保证等概率的前提下，尽可能多的利用生成的数字，从而减少舍弃的数字比例，降低 while 重复执行的概率



