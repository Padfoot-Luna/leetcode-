[TOC]

## List

列表的实现方式：

- 数组：有索引（给定索引，一步访问到数组中的元素，时间复杂度为$O(1)$)
    - :warning:索引不要超
    - 排序
    - 二维数组
- 链表

## LinkedList




## Hash

`哈希表（散列表）` 是一种空间换时间使用哈希函数组织数据的数据结构，它支持**快速插入和搜索**。

借助 `哈希函数`，将键映射到存储桶地址。

- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；
- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

```python
class Hashtable:
    def __init__(self, elements):
        self.bucket_size = len(elements)
        self.buckets = [[] for i in range(self.bucket_size)]
        self._assign_buckets(elements)

    def _assign_buckets(self, elements):
        for key, value in elements:
            hashed_value = hash(key)
            index = hashed_value % self.bucket_size
            self.buckets[index].append((key, value))

    def get_value(self, input_key):
        hashed_value = hash(input_key)
        index = hashed_value % self.bucket_size
        bucket = self.buckets[index]
        for key, value in bucket:
            if key == input_key:
                return(value)
        return None
```

多个键被映射到了同一个桶中，我们称之为 `哈希冲突`。

1. **线性试探法** 当插入键 `key` 时，如果发现桶单元 `bucket[hash(key)]` 已经被占用，则向下线性寻找，直到找到可以使用的空桶。

 	2. **链地址法 ** 将桶内产生冲突的键串联成一个链表
 	3. **再哈希法** 发生冲突时，通过使用另一个哈希函数来避免冲突
 	4. **公共溢出区法** 建立另一个哈希表 `dict_overflow` 作为公共溢出区，当发成冲突时则将该键保存在该哈希表中。

`桶`的实现：

1. 用数组来存储桶的所有值，需要$O(N)$ 的时间复杂度进行插入和删除，而不是$O(1)$。
2. 用链表
3. 用二叉搜索树作为桶



### 1.1 哈希集合 Set

### 1.2 哈希映射 Dictionary



---

## Heap

> 一个可以被看成近似完全二叉树的数组。堆包括最大堆和最小堆：
> - 最大堆的每一个节点（除了根结点）的值不大于其父节点；
> - 最小堆的每一个节点（除了根结点）的值不小于其父节点。
>
> heapq堆常见的操作：
>
> - Heapify() 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $O(n)$。
> - Heappush()：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $O(\log n)$。
> - Heappop()：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $O(\log n)$。
> - Heapsort：借由 Heapfy 建堆和 Heappop 堆数组进行排序，时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。
>
> 堆结构的一个常见应用是建立优先队列（Priority Queue）。





## Tree 树

- 存储结构
    1. 双亲表示法
    2. 孩子表示法
    3. 孩子兄弟表示法
- 树，二叉树，森林的转换
    1. 树转换二叉树
    2. 森林转二叉树
    3. 二叉树转树



## 字典树





## B树

> 平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构。
>
> B树，也称B-树，属于多叉树又名平衡多路查找树（查找路径不只两个），在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速度，B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。

https://www.cnblogs.com/nullzx/p/8729425.html

### 规则

- m：阶数，表示了一个节点最多有m个子节点
- 每个节点中存储了关键字（key）和关键字对应的数据（data），以及孩子节点的指针
- 排序方式：所有节点关键字是按递增次序排列，每个关键字的左子树的所有关键字都小于它，右子树的所有关键字都大于它
- 关键字数：每个节点最多有$m-1$个关键字，根节点的关键字数范围：$1\leq k\leq m-1$，非叶子节点的关键字数范围：$m//2\leq k\leq m-1$
- 所有叶子节点均在同一层

### 插入

插入操作是指插入一条记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key，则一定是在叶子结点中进行插入操作。

1. 根据要插入的key的值，找到叶子结点并插入。

2. 判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。
3. 以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

### 删除

删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。

1. 如果当前需要删除的key位于非叶子结点上，则用后继key覆盖要删除的key，然后在后继key所在的子支中删除该后继key。后继key一定位于叶子结点上，删除这个记录后执行第2步

2. 如果该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。

3. 如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。

    否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

    有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。

## B+ 树

> B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定

- 与B树相同点
    - 根结点至少一个元素
    - 非根结点的元素个数范围：$m/2\leq k\leq m-1$

- 与B树不同点
    1. B+树包含2种类型的结点：**内部结点**（也称索引结点）和**叶子结点**。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。
    2. B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。
    3. m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。
    4. 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都**小于**它，右子树中的key都**大于等于**它。叶子结点中的记录也按照key的大小排列。
    5. 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- - B+树的**非叶子**节点不保存关键字，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加
    - B+树**叶子**节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样
    - B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针
    - 非叶子节点的子节点数=关键字数（有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）

### 插入

1. 若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。
2. 针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。
3. 针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。

### 删除

如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤

1. 删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。

2. 若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。

3. 若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。

4. 若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步

5. 若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步

6. 当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。

    注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。

B+ 树相比于B树的优势：

- 单一节点存储的元素更多，使得搜索次数更少
- 所有查询都要查到叶子节点，查询性能稳定
- 所有叶子节点形成一个有序链表，更便于查找



## 红黑树

> https://www.jianshu.com/p/e136ec79235c
>
> 红黑树是一种含有红黑结点并能自平衡的二叉搜索树BST。自动维护其中元素的顺序，操作效率是 O(logN)。
>
> 1. 每个节点要么是黑色，要么是红色。
> 2. 根节点是黑色。
> 3. 每个叶子节点是黑色。
> 4. 每个红色结点的两个子结点一定都是黑色。
> 5. 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。

- 红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。
- `AVL树`是带有平衡条件的二叉查找树， 只要不满足就要通过旋转来保持平衡，而旋转是非常**耗时**的，由此**AVL树适合用于插入与删除次数比较少，但查找多的情况**
- 



## Binary Indexed Tree 树状数组

> 用于高效处理对一个存储数字的列表进行更新及**求前缀和**的数据结构。
>
> 它事实上并不是一棵树，而是根据数字的二进制表示来对数组中的元素进行逻辑上的分层存储。
>
> - 空间复杂度$O(N)$，需要额外声明一个数组BIT
>
> - 更新与求前缀和的时间复杂度都是$O(\log(n))$

1. `update(idx, delta)`：将`num`**加**到位置`idx`的数字上。
2. `prefixSum(idx)`：求从数组第一个位置到第`idx`（含`idx`）个位置所有数字的和。
3. `rangeSum(from_idx, to_idx)`：求从数组第`from_idx`个位置到第`to_idx`个位置的所有数字的和

![img](https://img-blog.csdn.net/20151203101825625)

- 【构造】树状数组中的每个元素是原数组中一个或者多个连续元素的和

    - $a$: 保存原始数据的数组
        BIT: 树状数组，其中的任意一个元素BIT$[i]$可能是一个或者多个$a$数组中元素的和。
        BIT$[i]$中的元素：如果数字 $i$ 的二进制表示中末尾有**$k$个连续的0，则BIT$[i]$是数组$a$中$2^k$个元素的和**，BIT$[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i-1]+a[i]$。**BIT$[i]$中每一个元素管理着a中若干个元素的和，并且各个元素管理的区间没有重叠。**
    - 计算$2^k$的两个方法
        - $2^k = i \& (\sim i+1)=i \& (-i)$ (利用机器补码特性)

    ```python
    def construtBIT(a):
        BIT = [0]  # index从1开始
        for i in range(1,len(a)+1):
            BIT.append(sum(a[i-2**int(math.log(i & -i,2)):i]))
        return BIT
    ```

- 【低位运算】

    ```python
    def lowbit(x):
        return x & -x
    ```

    

    - $lowbit(i) = ( (i-1) ^ i) \& i =  i \& (-i)$
    - 节点$e[i]$的父节点为 $e[ i - lowbit(i) ]$
    - 节点$e[i]$的子节点为 $e[ i + lowbit(i) ]$

- 【求和】在进行连续求和操作时，只需要将树状数组中某几个元素的和即可

    ```python
    def prefixSum(idx):
         idx += 1
         sum = 0
         while idx > 0:
        	sum += BIT[idx]
        	idx -= lowbit(idx)  # father
         return sum
    ```

    - `prefixSum(i)`= BIT$[i]$ + BIT[father($i$)] + BIT[father(father($i$))] + ...(直到0)

- 【更新】

    ```python
    def update(idx, delta):
        idx += 1
        while idx < len(BIT):
            BIT[idx] += delta
            idx += lowbit(idx)   # child
    ```
     - `update(i,delta)` : `update(i,delta)`+`update(child(i),delta)`+ `update(child(child(i)),delta)`+ ...（直到越界）



## Huffman encoding 哈夫曼编码

> huffman 编码的目的找出存放一串字符所需的最少的二进制编码。即哈夫曼树带权路径WPL长度最小。
>
> 基本思想就是`用短的编码表示长的字符序列，用长的编码来表示短的字符序列`，从而实现压缩的目的。 因此huffman编码被广泛地应用于无损压缩领域。

- 构建huffman树（又叫最优二叉树）：huffman 树就像是一个堆。 真正执行编码的时候，类似字典树，节点不用来编码，节点的路径用来编码。
    1. 首先统计出每种字符出现的频率
    2. 找出字符中最小的两个，小的在左边，大的在右边，组成二叉树。在**频率表**中删除此次找到的两个数，并加入此次最小两个数的频率和。
    3. 重复第2步
- 哈夫曼树的字母都在叶子节点上，保证了长编码的不与短编码的字母冲突
- 哈夫曼树的构造并不是唯一的：**同权不同构**

```python
class Node(object):
    def __init__(self,name=None,value=None):
        self._name = name
        self._value = value
        self._left = None
        self._right = None

class HuffmanTree(object):
    #根据Huffman树的思想：以叶子节点为基础，反向建立Huffman树
    def __init__(self, char_weights):
        self.nodes = []
        self.codings = {}
        for name, value in char_weights:
            self.nodes.append(Node(name, value))  # 根据输入的字符及其频数生成叶子节点
            self.codings[name] = ''  # self.b用于保存每个叶子节点的Haffuman编码
        while len(self.nodes) > 1:    
            self.nodes.sort(key = lambda node: node._value, reverse=True)
            c = Node(value = self.nodes[-1]._value+self.nodes[-2]._value)
            c._left = self.nodes.pop()
            c._right = self.nodes.pop()
            self.nodes.append(c)
        self.root=self.nodes[0]

    #用递归的思想生成编码
    def dfs(self, node, path):
        if not node._left and not node._right:
            self.codings[node._name] = path
            return
        self.dfs(node._left, path+'0')
        self.dfs(node._right, path+'1')
    
    #生成哈夫曼编码   
    def get_code(self):
        self.dfs(self.root, '')

if __name__=='__main__':
    char_weights = [('a',5),('b',4),('c',10),('d',8),('f',15),('g',2)]  # 输入的是字符及其频数
    tree = HuffmanTree(char_weights)
    tree.get_code()
    print(tree.codings)
```



  

## run-length encode 游程编码

> 游程编码是一种比较简单的压缩算法，其基本思想是将重复且连续出现多次的字符使用（连续出现次数，某个字符）来描述。

比如 AAAAABBBBCCC 使用游程编码可以将其描述为：5A4B3C