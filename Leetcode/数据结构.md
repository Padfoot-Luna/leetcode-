[TOC]

## List

列表的实现方式：

- 数组：有索引（给定索引，一步访问到数组中的元素，时间复杂度为$O(1)$)
    - :warning:索引不要超
    - 排序
    - 二维数组
- 链表

## LinkedList




## Hash

`哈希表` 是一种使用哈希函数组织数据的数据结构，它支持**快速插入和搜索**。

借助 `哈希函数`，将键映射到存储桶地址。

- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；
- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

```python
class Hashtable:
    def __init__(self, elements):
        self.bucket_size = len(elements)
        self.buckets = [[] for i in range(self.bucket_size)]
        self._assign_buckets(elements)

    def _assign_buckets(self, elements):
        for key, value in elements:
            hashed_value = hash(key)
            index = hashed_value % self.bucket_size
            self.buckets[index].append((key, value))

    def get_value(self, input_key):
        hashed_value = hash(input_key)
        index = hashed_value % self.bucket_size
        bucket = self.buckets[index]
        for key, value in bucket:
            if key == input_key:
                return(value)
        return None
```

多个键被映射到了同一个桶中，我们称之为 `哈希冲突`。

1. **线性试探法** 当插入键 `key` 时，如果发现桶单元 `bucket[hash(key)]` 已经被占用，则向下线性寻找，直到找到可以使用的空桶。

 	2. **链地址法 ** 将桶内产生冲突的键串联成一个链表
 	3. **再哈希法** 发生冲突时，通过使用另一个哈希函数来避免冲突
 	4. **公共溢出区法** 建立另一个哈希表 `dict_overflow` 作为公共溢出区，当发成冲突时则将该键保存在该哈希表中。

`桶`的实现：

1. 用数组来存储桶的所有值，需要$O(N)$ 的时间复杂度进行插入和删除，而不是$O(1)$。
2. 用链表
3. 用二叉搜索树作为桶



### 1.1 哈希集合 Set

### 1.2 哈希映射 Dictionary



---

## Heap

> 一个可以被看成近似完全二叉树的数组。堆包括最大堆和最小堆：
> - 最大堆的每一个节点（除了根结点）的值不大于其父节点；
> - 最小堆的每一个节点（除了根结点）的值不小于其父节点。
>
> 堆常见的操作：
>
> - Heapfy 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $O(n)$。
> - Heappush：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $O(\log n)$。
> - Heappop：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $O(\log n)$。
> - Heapsort：借由 Heapfy 建堆和 Heappop 堆数组进行排序，时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。
>
> 堆结构的一个常见应用是建立优先队列（Priority Queue）。







## 树状数组（Binary Indexed Tree）

> 用于高效处理对一个存储数字的列表进行更新及**求前缀和**的数据结构。
>
> 它事实上并不是一棵树，而是根据数字的二进制表示来对数组中的元素进行逻辑上的分层存储。
>
> - 空间复杂度$O(N)$，需要额外声明一个数组BIT
>
> - 更新与求前缀和的时间复杂度都是$O(\log(n))$

1. `update(idx, delta)`：将`num`**加**到位置`idx`的数字上。
2. `prefixSum(idx)`：求从数组第一个位置到第`idx`（含`idx`）个位置所有数字的和。
3. `rangeSum(from_idx, to_idx)`：求从数组第`from_idx`个位置到第`to_idx`个位置的所有数字的和

![img](https://img-blog.csdn.net/20151203101825625)

- 【构造】树状数组中的每个元素是原数组中一个或者多个连续元素的和

    - $a$: 保存原始数据的数组
        BIT: 树状数组，其中的任意一个元素BIT$[i]$可能是一个或者多个$a$数组中元素的和。
        BIT$[i]$中的元素：如果数字 $i$ 的二进制表示中末尾有**$k$个连续的0，则BIT$[i]$是数组$a$中$2^k$个元素的和**，BIT$[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i-1]+a[i]$。**BIT$[i]$中每一个元素管理着a中若干个元素的和，并且各个元素管理的区间没有重叠。**
    - 计算$2^k$的两个方法
        - $2^k = i \& (\sim i+1)=i \& (-i)$ (利用机器补码特性)

    ```python
    def construtBIT(a):
        BIT = [0]  # index从1开始
        for i in range(1,len(a)+1):
            BIT.append(sum(a[i-2**int(math.log(i & -i,2)):i]))
        return BIT
    ```

- 【低位运算】

    ```python
    def lowbit(x):
        return x & -x
    ```

    

    - $lowbit(i) = ( (i-1) ^ i) \& i =  i \& (-i)$
    - 节点$e[i]$的父节点为 $e[ i - lowbit(i) ]$
    - 节点$e[i]$的子节点为 $e[ i + lowbit(i) ]$

- 【求和】在进行连续求和操作时，只需要将树状数组中某几个元素的和即可

    ```python
    def prefixSum(idx):
         idx += 1
         sum = 0
         while idx > 0:
        	sum += BIT[idx]
        	idx -= lowbit(idx)  # father
         return sum
    ```

    - `prefixSum(i)`= BIT$[i]$ + BIT[father($i$)] + BIT[father(father($i$))] + ...(直到0)

- 【更新】

    ```python
    def update(idx, delta):
        idx += 1
        while idx < len(BIT):
            BIT[idx] += delta
            idx += lowbit(idx)   # child
```
    
    - `update(i,delta)` : `update(i,delta)`+`update(child(i),delta)`+ `update(child(child(i)),delta)`+ ...（直到越界）

