[TOC]

## List

列表的实现方式：

- 数组：有索引（给定索引，一步访问到数组中的元素，时间复杂度为$O(1)$)
    - :warning:索引不要超
    - 排序
    - 二维数组
- 链表

## LinkedList




## Hash

`哈希表` 是一种使用哈希函数组织数据的数据结构，它支持**快速插入和搜索**。

借助 `哈希函数`，将键映射到存储桶地址。

- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；
- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

```python
class Hashtable:
    def __init__(self, elements):
        self.bucket_size = len(elements)
        self.buckets = [[] for i in range(self.bucket_size)]
        self._assign_buckets(elements)

    def _assign_buckets(self, elements):
        for key, value in elements:
            hashed_value = hash(key)
            index = hashed_value % self.bucket_size
            self.buckets[index].append((key, value))

    def get_value(self, input_key):
        hashed_value = hash(input_key)
        index = hashed_value % self.bucket_size
        bucket = self.buckets[index]
        for key, value in bucket:
            if key == input_key:
                return(value)
        return None
```

多个键被映射到了同一个桶中，我们称之为 `哈希冲突`。

1. **线性试探法** 当插入键 `key` 时，如果发现桶单元 `bucket[hash(key)]` 已经被占用，则向下线性寻找，直到找到可以使用的空桶。

 	2. **链地址法 ** 将桶内产生冲突的键串联成一个链表
 	3. **再哈希法** 发生冲突时，通过使用另一个哈希函数来避免冲突
 	4. **公共溢出区法** 建立另一个哈希表 `dict_overflow` 作为公共溢出区，当发成冲突时则将该键保存在该哈希表中。

`桶`的实现：

1. 用数组来存储桶的所有值，需要$O(N)$ 的时间复杂度进行插入和删除，而不是$O(1)$。
2. 用链表
3. 用二叉搜索树作为桶



### 1.1 哈希集合 Set

### 1.2 哈希映射 Dictionary



---

## Heap

> 一个可以被看成近似完全二叉树的数组。堆包括最大堆和最小堆：
> - 最大堆的每一个节点（除了根结点）的值不大于其父节点；
> - 最小堆的每一个节点（除了根结点）的值不小于其父节点。
>
> 堆常见的操作：
>
> - Heapfy 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $O(n)$。
> - Heappush：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $O(\log n)$。
> - Heappop：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $O(\log n)$。
> - Heapsort：借由 Heapfy 建堆和 Heappop 堆数组进行排序，时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。
>
> 堆结构的一个常见应用是建立优先队列（Priority Queue）。



