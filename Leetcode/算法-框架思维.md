[TOC]
---
> :thinking: 递归和迭代是*实现手段*，分治策略、动态规划、贪心是解决问题的*思想*。

#### 递归

> 重复调用函数自身实现循环称为`递归`。
>
> 本质是能把问题拆分成具有**相同解决思路**的子问题， 经过层层分解的子问题最后一定是有一个不能再分解的固定值的（即**终止条件**）。
>
> 计算时间复杂度： `Master Theorm` 
>
> 空间复杂度：递归深度

#### 迭代

> `迭代`是函数内某段代码实现循环，使用**计数器**结束循环。
>
> 迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值，利用变量的原值推出新值。



#### 所有的递归可以转换为迭代，但迭代不一定可以转换成递归

- 一部分`递归`算法，可以转成`动态规划`，实现空间换时间, 例如 [5题](https://leetcode.windliang.cc/leetCode-5-Longest-Palindromic-Substring.html)，[10题](https://leetcode.windliang.cc/leetCode-10-Regular-Expression-Matching.html)，[53题](https://leetcode.windliang.cc/leetCode-53-Maximum-Subarray.html?h=动态规划)，[72题](https://leetcode.wang/leetCode-72-Edit-Distance.html)，从自顶向下再向顶改为了自底向上。分析问题我们需要采用**自上而下**的思维，而解决问题有时候采用**自下而上**的方式能让算法性能得到极大提升。
- 一部分`递归`算法，只是可以用`栈`去模仿递归的过程，对于时间或空间的复杂度没有任何好处。

---

#### `分治 Divide and Conquer`

将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），递归的求解这些子问题（Conquer），然后再合并这些子问题的解来建立原问题的解。一般用`递归`实现。



#### `动态规划 Dynamic Programming`

> 递归是从问题的结果倒推，直到问题的规模缩小到寻常。 动态规划是从寻常入手， 逐步扩大规模到**「最优子结构」**。

动态规划可以理解为是**查表**的递归, **用来解决存在「重叠子问题」的问题**。递归中可能存在很多的重复计算，一种简单的方式就是记忆化递归。即一边递归一边使用“记录表”记录我们已经计算过的情况，这样就避免了重复计算。而动态规划中 DP 数组其实和“记录表”一样。

动态规划问题的一般形式就是**求最值**，求解动态规划的核心问题是**穷举**。一般由两种方法来实现，一种为自顶向下的带备忘录的`递归`，一种为自底向上的`迭代`。

只有列出**正确的「状态转移方程」**才能正确地穷举。找**最优子结构**的过程，其实就是证明状态转移方程正确性的过程。

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

只要写出状态转移方程即暴力解法，优化方法无非是用备忘录或者 DP table，即「**状态压缩**」，再无奥妙可言。









#### `背包问题`
> 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

##### 1. 0-1 背包问题：每种物品数量为 1，放或不放

$f[i][v]$表示前 $i$ 件物品放入一个容量为$v$的背包可以获得的最大价值。

$f[i][v]=\max\{f[i-1][v], f[i-1][v-c[i]]+w[i]\}$    # 不放 or 放

`优化`：时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。

```python
for i in range(N):   # # 枚举前 i 个物品
	for v in range(V, c[i]-1, -1):  # 枚举体积，逆推f[v]保证推f[v]时f[v-c[i]]保存的是f[i-1][v-c[i]]的值
		f[v] = max(f[v], f[v-c[i]]+w[i])
```

---

##### 2. 完全背包问题：每种物品都有无限件可用

$f[i][v]=\max\{f[i-1][v-k*c[i]]+k*w[i]\;|\;0\leq k\leq v/c[i]\}$

```python
for i in range(N):  # 枚举前 i 个物品
    for v in range(c[i], V+1):  # 注意这里是正序遍历
        f[v] = max(f[v], f[v-c[i]]+w[i])
```

---

##### 3. 多重背包问题

##### 4. 混合背包问题

##### 5. 二维费用背包问题

##### 6. 分组背包问题

##### 7. 背包问题求方案数

##### 8. 背包问题的方案

##### 9. 有依赖的背包问题



#### `贪心算法 Greedy Algorithm`

贪心算法不从整体最优考虑，在每一步做出某种意义上的局部最优解，希望这样的选择能导致全局最优解。但只是寄希望，因此贪心算法并不保证得到最优解。既可以用`递归`实现，也可以用`迭代`实现。

关键是贪心策略的选择



#### `回溯 Backtracking`

回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。究其本质，回溯算法就是个 N 叉树的前后序遍历问题，没有例外。

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择
        路径.remove(选择)
        将该选择再加入选择列表
```

比如，DFS。

```python
class Sulution():
    res = []    # 定义全局变量保存最终结果
    state = []  # 定义状态变量保存当前状态
    p,q,r       # 定义条件变量（一般条件变量就是题目直接给的参数）
    def back(状态，条件1，条件2，……):
        if # 不满足合法条件（可以说是剪枝）
            return
        elif # 状态满足最终要求
            res.append(state)   # 加入结果
            return 
        # 主要递归过程，一般是带有 循环体 或者 条件体
        for # 满足执行条件
        if  # 满足执行条件
            back(状态，条件1，条件2，……)
    back(状态，条件1，条件2，……)
    return res
```







#### `二分查找`

细节是魔鬼 https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484507&idx=1&sn=36b8808fb8fac0e1906493347d3c96e6&source=41#wechat_redirect

```python
def binarySearch(nums, target):
	left, right = 0, len(nums)-1
    while:  # 注意「搜索区间」和 while 的终止条件
        mid = (right + left) // 2;
        if nums[mid] == target:  # 如需要搜索左右边界，只要在 nums[mid] == target 
            ...   
        elif nums[mid] < target:
            left = 
        else:  # nums[mid] > target
            right = 
    return
```



#### `滑动窗口`

```python
/* 滑动窗口算法框架 */
def slidingWindow(string s, string t):
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    left = right = 0
    valid = 0
    while right < s.size():
        # c 是将移入窗口的字符
        c = s[right]
        right += 1  # 右移窗口
        # 进行窗口内数据的一系列更新
        ...

        # debug 输出的位置
        print("window: [%d, %d)\n", left, right)
        
        // 判断左侧窗口是否要收缩
        while window needs shrink:
            # d 是将移出窗口的字符
            d = s[left]
            left +=1  # 左移窗口
            # 进行窗口内数据的一系列更新
            ...
```



---

#### 时间复杂度

- `递归`算法的时间复杂度怎么计算？就是用子问题个数(即递归树中节点的总数)乘以解决一个子问题需要的时间。



#### 空间复杂度

- `递归`是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。

- `迭代`是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。



---

####  Math

##### [XOR][]

恒等律：`X ⊕ 0 = X`      

归零律：`X ⊕ X = 0`

交换律：`A ⊕ B = B ⊕ A`

结合律：`A ⊕ (B ⊕ C) = (A ⊕ B) ⊕ C`

自反律：`A ⊕ B ⊕ B = A ⊕ 0 = A`    去重

##### [mod][]

结合律：`(a*b)%k = (a%k)(b%k)%k`   



---

#### 图：最短路径
##### 单源最短路径 - Dijkstra: 

- BFS + Greedy
- 要求图中边的权值均为非负

```markdown
1. 初始化：声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T。初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w(s,t) ,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。
2. 从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，
3. 我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。
4. 重复2和3，直到T中包含了图的所有顶点。
```

- 时间复杂度：$O(V^2)$。 dis用heap，复杂度可以降为$O(E+V\log V)$
- 空间复杂度：$O(V)$

---

##### 单源最短路径 - SPFA  / aka Moore-Bellman-Ford

- Dynamic programming
- 权值可为负

```markdown
1. 用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G
2. 采取动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行**松弛操作**，如果源点到v点的最短路径有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止
3. 带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：
	    1. 开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）
        2. 如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）

```

- 时间复杂度：$O(EV)$。
- 空间复杂度：$O(V)$

---

##### 多源最短路径 - Floyd

```markdown
1. 初始化：矩阵D中的元素a[i][j]表示顶点i到顶点j的距离。
        (如果需要最短路径）矩阵P中的元素b[i][j]，表示顶点i到顶点j经过了顶点b[i][j]
2. 对矩阵D进行N次更新。
        第k次更新时，如果a[i][j]>a[i][k-1]+a[k-1][j]，则更新a[i][j]=a[i][k-1]+a[k-1][j],b[i][j]=b[i][k-1]
```

- 时间复杂度：$O(V^3)$。

- 空间复杂度：$O(V^2)$





---

#### Union-Find 并查集



